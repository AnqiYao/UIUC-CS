/**
* Text Editor Lab
* CS 241 - Spring 2018
*/

#include "document.h"
#include "editor.h"
#include "format.h"
#include "sstream.h"

#include <assert.h>
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CSTRING(x) ((bytestring){(char *)x, -1})
#define DECLARE_BUFFER(name) bytestring name = {NULL, 0};
#define EMPTY_BYTES ((bytestring){NULL, 0})

char *get_filename(int argc, char *argv[]) {
    // TODO implement get_filename
    // take a look at editor_main.c to see what this is used for
//	if(argc<0){
//		return NULL;
//	}	
	return argv[1];
}

sstream *handle_create_stream() {
    // TODO create empty stream
	sstream* temp = sstream_create(EMPTY_BYTES);
   	return temp;
}
document *handle_create_document(const char *path_to_file) {
    // TODO create the document
    return document_create_from_file(path_to_file);
}

void handle_cleanup(editor *editor) {
    // TODO destroy the document
	document_destroy((*editor).document);
}

void handle_display_command(editor *editor, size_t start_line,
                            ssize_t max_lines, size_t start_col_index,
                            ssize_t max_cols) {
    // TODO implement handle_display_command
	if(max_lines == -1){
		while(start_line <= document_size(editor->document)){
			char* line = document_get_line(editor->document, start_line);
			line += start_col_index;
			if(max_cols == -1) printf("%s\n", line);
			else write(1,"%s\n",line,max_cols);
			start_line++;
		}
	}
	else{
		while(start_line <= document_size(editor->document) && max_lines>0){
			char* line = document_get_line(editor->document, start_line);
			line += start_col_index;
			if(max_cols == -1) printf("%s\n", line);
			else write(1,"%s\n",line,max_cols);
			start_line++;
			max_lines --;
		}
	}
}

void handle_insert_command(editor *editor, location loc, const char *line) {
    // TODO implement handle_insert_command
	document_insert_line(editor->document, loc.line_no, line);
}

void handle_append_command(editor *editor, size_t line_no, const char *line) {
    // TODO implement handle_append_command
	if(line_no > document_size(editor->document))	
		document_insert_line(editor->document, loc.line_no, line);
	else{
		char* old = document_get_line(editor->document, loc.line_no);	
		old += strlen(old);
		while(*line){
			if((*line == '\')&&(line[1] == '\0')){
				line++;
			}
			else if(*line == '\n'){
				*old = '\';
				old++;
				line++;
			}
			else{
			*old = *line;
			old++;
			line++;
			}	
		}
		*old = '\0';	
	}
}

void handle_write_command(editor *editor, size_t line_no, const char *line) {
    // TODO implement handle_write_command
	if(line_no > document_size(editor->document))	
		document_insert_line(editor->document, loc.line_no, line);
	else{
		char* old = document_get_line(editor->document, loc.line_no);	
		while(*line){
			if((*line == '\')&&(line[1] == '\0')){
				line++;
			}
			else if(*line == '\n'){
				*old = '\';
				old++;
				line++;
			}
			else{
			*old = *line;
			old++;
			line++;
			}	
		}
		if(*old) old[0] = '\0'; 	
	}
}

void handle_delete_command(editor *editor, location loc, size_t num_chars) {
    	// TODO implement handle_delete_command
	if(loc.line_no > document_size(editor->document)){
		// ?????Can we get the Angrave's answer here?
		int max = document_size(editor->document);
		num = loc.line_no;
		while(num > max){
			document_delete_line(editor->document, num);
			num--;
		}
		return;
	} 
	char* line = document_get_line(editor->document, loc.line_no);
	if(strlen(line) - idx <= num_chars){
		line[idx] = '\0';
	}else{
		line += idx;
		whlie(line[num_chars]){
			*line = line[num_chars];
			line++;
		} 
		line++ = '\0';
	}
}

void handle_delete_line(editor *editor, size_t line_no) {
    // TODO implement handle_delete_line
	if(line_no <= document_size(editor->document))
		document_delete_line(editor->document, line_no);
}

location handle_search_command(editor *editor, location loc,
                               const char *search_str) {
    // TODO implement handle_search_command
    	if(*search_str == "") return (location){0, 0};
	if(loc.line_no > document_size(editor->document)) return (location){0, 0};
	char * line = document_get_line(editor->document, loc.line_no);
	if(strlen(search_str) > (strlen(line)-loc.idx)) return (location){0, 0};
	line += loc.idx;
	int new_idx = 0;
	int found = 1;
	while(line[new_idx]){
		if(line[new_idx] == search_str[0]){
			int i;
			for(i = 1; i < strlen(search_str);i++){
				if(found!=1)
					break;
				else {
					if(line[new_idx+i] != search_str[i]) 
						found = 0;
				}
			}
			if (found == 1) return (location) {loc.line_no,loc.idx+new_idx}
		}
		found = 1;
		new_idx += 1;				
	}
	return (location){0, 0};
}

void handle_merge_line(editor *editor, size_t line_no) {
    // TODO implement handle_merge_line
	char* old = document_get_line(editor->document, line_no);
	char* line = document_get_line(editor->document, line_no+1);
	document_delete_line(editor->document, line_no+1);
	old += strlen(old);
	while(*line){
		*old = *line;
		old++;
		line++;
	}
	*old = '\0';
}

void handle_split_line(editor *editor, location loc) { 
    // TODO implement handle_split_line
	char* old = document_get_line(editor->document, loc.line_no);
	old = old+loc.idx;
	document_insert_line(editor->document, loc.line_no + 1, old);
	*old = '\0';
	return;	
}

void handle_save_command(editor *editor) {
    // TODO implement handle_save_command	
	document_write_to_file(editor->document, editor->filename);
}

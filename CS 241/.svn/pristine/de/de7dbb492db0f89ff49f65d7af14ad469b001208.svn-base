/**
* Shell Lab
* CS 241 - Spring 2018
*/

#include "format.h"
#include "shell.h"
#include "vector.h"
#include <unistd.h>
#include <stdio.h>
#include <string.h>

typedef struct process {
    char *command;
    char *status;
    pid_t pid;
} process;

//return -1 if the build in command cannot be done
void build_in_commands(const char** object,int check,int count){
	if (check == 1){
		if(count!=2 ){
			print_invalid_command(object[0]);
			fflush(stdout);
	 		return;	
		}
		char* temp = NULL;
		if(strncmp(object[1],"/",1) !=0){
			temp = getcwd(NULL,0); 
	        	strcat(temp,"/");
			strcat(temp,object[1]);
		}
		else{
			temp = object[1];	
		}
		int temp1 = chdir(temp);
		if(temp1 == -1)	{
			print_no_directory(temp);
			fflush(stdout);
		}
	}
	else if(check == 2){
		
	}	
}

//return 0 if it is not build in command
int bool_build_in(const char* command){
	if(strcmp(command,"cd") == 0)	return 1;
	else if(strcmp(command,"!history") == 0) return 2;
	else if(strncmp(command,"!",1) == 0)	return 3;
	else if(strncmp(command,"#",1) == 0 && command[1]!=NULL && isdigit(command[1]))	return 4;
	else if(strncmp(command,"ps",2) == 0)	return 5;
	else if(strcmp(command,"exit") == 0)	return 6;
	else if((strcmp(command,"kill") == 0)| (strcmp(command,"stop") == 0)| (strcmp(command,cont) == 0))	return 7;
	
	return 0;	 
}

int shell(int argc, char *argv[]) {
    // TODO: This is the entry point for your shell.
	if(argc<2){
		print_usage();
		exit(1);
	}

//start
	pid_t mainid = getpid();
	int temp = getopt(argc,argv,"fh");
	while(temp!=-1){
		if(temp == 'f'){
			char* file_name = argv[2];
			FILE* file_t = fopen(file_name,"r"); 
			if(file_t == NULL){
				print_script_file_error();
				fflush(stdout);
				exit(1);
			}
			char* file_buffer = NULL;
			size_t num;
			ssize_t read = 0;
			while(read = getline(&file_buffer, &num,file_t)!= -1){
			
			char* command;
			char** object = malloc(1024);
			command = strtok(file_buffer," ");
			int i = 0;
			while(command != NULL){
				object[i] = command;
				i++;
				command = strtok(NULL," ");
			}
			command = object[0];
			char* temp = getcwd(NULL,0);
                        print_prompt(temp,mainid);
                        print_commnad(command);
                        fflush(stdout);
                        free(temp);

			int check = bool_build_in(command);	
			if(check != 0){
				build_in_commands(object,check,i);
			}
			else {
			pid_t id = fork();
			if(id == -1){
				print_fork_failed();
				exit(1);
			   }
			else if(id > 0){
				int status;
				pid_t pid = waitpid(id,&status,0);
				if(pid!=-1 && WIFEXITED(status)){
					int exit_status = WEXITSTATUS(status);
                                if(exit_status != 0){
                                       	exit(1);
                          	}	
			    }
			  }
			else{	
				print_command_executed(id);
				fflush(stdout);
				execvp(file_buffer,&file_buffer);
				print_exec_failed(file_buffer);
				fflush(stdout);	
				exit(1);
			   }
		        }

		    }//end read 
                }
		
			else if(strcmp(argv[num],"-h")){
				return 1;
			}
		}
		else if(temp == 'h'){
			pid_t id = fork();
			if(id == -1){
				print_fork_failed();
				fflush();
				exit(1);
			}
			else if(id == 0)
			else{
				return 1;
			}
		}
		else if(temp == '?'){
			return 1;
		}
		temp = getopt(argc,argv,"fh");
	}
    return 0;
}

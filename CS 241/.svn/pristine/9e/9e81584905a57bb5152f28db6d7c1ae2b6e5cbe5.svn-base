/**
* Shell Lab
* CS 241 - Spring 2018
*/

#include "format.h"
#include "shell.h"
#include "vector.h"
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/wait.h>

typedef struct process {
    char *command;
    char *status;
    pid_t pid;
} process;

static vector* history_string;
static pid_t id = 0;
static FILE* file_saving = NULL;
static int flag = 1;


void* process_copy_constructor(void*elem){
	process* newone = calloc(1,sizeof(process));
	process* oldone = (process*)elem;
	char* newCm;
	char* newSt;


	if (oldone->command != NULL)
	{
		newCm = strdup(oldone->command);
	}
	else
		newCm = NULL;
	if (oldone->status != NULL)
	{
	    newSt = strdup(oldone->status);
	}
	else
		newSt = NULL;
	newone->command = newCm;
	newone->status = newSt;
	newone->pid = oldone->pid;
	return newone;
}

void process_destructor(void* elem){
	if(elem == NULL)  	return;
  	process* oldone = (process*)elem;

	if (oldone->command != NULL)
		{
			free(oldone->command);
		}
	if (oldone->status != NULL)
	{
		free(oldone->status);
	}
	free(oldone);
  return;
}

void *process_default_constructor(void) { return calloc(1,sizeof(process)); }

vector *process_vector_create() {
	return vector_create(process_copy_constructor, process_destructor, process_default_constructor);
}

//return -1 if the build in command cannot be done
int build_in_commands(const char** object,int check,int count){
	char*command  = object[0];
	if (check == 1){
		if(count > 2 ){
			print_invalid_command(object[0]);
			fflush(stdout);
	 		return -1;	
		}
		if(count == 1){
			print_no_directory(NULL);
			fflush(stdout);
			return -1;
		}
		char* temp = NULL;
		if(strncmp(object[1],"/",1) !=0){
			temp = getcwd(NULL,0); 
	        	strcat(temp,"/");
			strcat(temp,object[1]);
		}
		else{
			temp = (char*)object[1];	
		}
		int temp1 = chdir(temp);
		if(temp1 == -1)	{
			print_no_directory(temp);
			fflush(stdout);
			free(temp);
			return -1;	
		}
	}else if(check == 2){
		size_t cur = 0;
		if(count!=1){
			print_invalid_command(command);
			fflush(stdout);
			return -1;
		}
		process* help;
		while(cur < vector_size(history_string)){
			help = vector_get(history_string, cur);
			print_history_line(cur,help->command);
			fflush(stdout);
			cur++;
		}
		return 0;
	}else if(check == 3){
		char* temp_3_1 = NULL;
		if(count = 1 && (strlen(command) == 1))	temp_3_1 = (vector_get(history_string, vector_size(history_string) - 1)) -> command;
		else 		
		{
			char* temp_3 = NULL;
			strcat(temp_3,command[1]);
			int k = 1;
			while(object[k]!=NULL){
				strcat(temp_3," ");
				strcat(temp_3,object[k]);
			}
			int length = strlen(temp_3);
			int isDone = 0;
			int j = 0;
			for(size_t i = vector_size(history_string) - 1; i >= 0; i--){
				temp_3_1 = (vector_get(history_string, vector_size(history_string) - 1)) -> command;
				j = 0;
				while(strlen(temp_3_1[j]) >= length){
					if(strncmp(temp_3_1[j],temp_3,length) == 0){
						isDone = 1;
						break;
					}	
					j++;
				}
				if(isDone)
					break;				
			}
			if(!isDone){
				print_no_history_match();
				fflush(stdout);
				return -1;
			}
			print_command(temp_3_1);
			fflush(stdout);
			ssize_t n_1 = 0;
			char** res4 = strsplit(temp4->command," ",&n_1);
			int count_4 = 0;
			while(res4[count_4]!=NULL)	count_4++;
			if(bool_build_in(res4[0]) != 0)	build_in_commands(res4, bool_build_in(res4[0]), count_4);
			else{
				process* ex;
				id = fork();
				if(id == -1){
					print_fork_failed();
					exit(1);
			   	}
				else if(id > 0){
					int status;
					pid_t pid = waitpid(id,&status,0);
					if(pid!=-1 && WIFEXITED(status)){
						int exit_status = WEXITSTATUS(status);
                                	if(exit_status != 0){
						print_wait_failed();
                                	       	exit(1);
                          		}	
			    	}
				}else{	
					print_command_executed(id);
					fflush(stdout);
					ex->command = temp4->command;
					ex->status = STATUS_RUNNING;
					ex->pid = id;
					vector_push_back(history_string,ex);
					execvp(temp4->command,&temp4->command);
					print_exec_failed(file_buffer);
					fflush(stdout);	
					exit(1);
			  	 }
			}	
		
		return 0;		
	}else if(check == 4){
		if(count!=1){
			print_invalid_command(command);	
			fflush(stdout);
			return -1;	
		}
		if(atoi(command[1]) >= vector_size(history_string)){
			print_invalid_index();
			fflush(stdout);
			return -1;
		}
		else{
			process* temp4 =vector_get(history_string, atoi(command[1]));
			print_command(temp4->command);
			fflush(stdout);
			ssize_t n_1 = 0;
			char** res4 = strsplit(temp4->command," ",&n_1);
			int count_4 = 0;
			while(res4[count_4]!=NULL)	count_4++;
			if(bool_build_in(res4[0]) != 0)	build_in_commands(res4, bool_build_in(res4[0]), count_4);
			else{
				process* ex;
				id = fork();
				if(id == -1){
					print_fork_failed();
					exit(1);
			   	}
				else if(id > 0){
					int status;
					pid_t pid = waitpid(id,&status,0);
					if(pid!=-1 && WIFEXITED(status)){
						int exit_status = WEXITSTATUS(status);
                                	if(exit_status != 0){
						print_wait_failed();
                                	       	exit(1);
                          		}	
			    	}
				}else{	
					print_command_executed(id);
					fflush(stdout);
					ex->command = temp4->command;
					ex->status = STATUS_RUNNING;
					ex->pid = id;
					vector_push_back(history_string,ex);
					execvp(temp4->command,&temp4->command);
					print_exec_failed(file_buffer);
					fflush(stdout);	
					exit(1);
			  	 }

			}	
		return 0;
	}else if(check == 5){
		if(count!=1){
			print_invalid_command(command);
			fflush(stdout);
			return -1;
		}
		else{
			for(size_t i = 0; i < vector_size(history_string); i++){
				process* theO = vector_get(history_string, i);
				if(strcmp("STATUS_RUNNING",theO->status) == 0){
					print_process_info(theO->status,theO->pid,theO->command);
					fflush(stdout);
				}
			}
		return 0;
	}else if(check == 7){
		if(count != 2){
			print_invalid_command(command);
			fflush(stdout);
			return -1;
		}
		else{
			int valid;
			int temp_6 = atoi(object[1]);
			valid = kill(temp_6, SIGTERM);
			if(valid!=0){
				print_no_process_found(temp_6);
				fflush(stdout);
				return -1;
			}
			else{
				process* theOn;
				int place = 0;
				for(size_t i = 0; i <vector_size(history_string);i++){
					theOn = (process*) vector_get(history_string,i);
					if(temp_6 == theOn->pid){
						place = i;
						break;
					}
				}
				print_killed_process(temp_6, theOn->command);
				fflush(stdout);
				vector_erase(history_string, place);
				}
			}
		return 0;
	}else if(check == 8){
		if(count != 2){
			print_invalid_command(command);
			fflush(stdout);
			return -1;
		}
		else{
			int valid;
			int temp_6 = atoi(object[1]);
			process* theOne;
			int place;
			valid = kill(temp_6, SIGSTOP);
			if(valid!=0){
				print_no_process_found(temp_6);
				fflush(stdout);
				return -1;
			}
			else{
				for(size_t i = 0; i <vector_size(history_string);i++){
					theOne = (process*) vector_get(history_string,i);
					if(temp_6 == theOne->pid){
						place = i;
						strcpy(theOne->status,"STATUS_STOPPED");
						break;
					}
				}
				print_stopped_process(temp_6, theOne->command);
				fflush(stdout);
				}
			}
		return 0;
	}else if(check == 9){
		if(count != 2){
			print_invalid_command(command);
			fflush(stdout);
			return -1;
		}
		else{
			int valid;
			int temp_6 = atoi(object[1]);
			process* theOne;
			int place;
			valid = kill(temp_6, SIGCONT);
			if(valid!=0){
				print_no_process_found(temp_6);
				fflush(stdout);
				return -1;
			}
			else{
				for(size_t i = 0; i <vector_size(history_string);i++){
					theOne = (process*) vector_get(history_string,i);
					if(temp_6 == theOne->pid){
						place = i;
						break;
					}
				}
				fflush(stdout);
				strcpy(theOne->status,"STATUS_RUNNING");
				}
			}
		return 0;
	}
}		


void INThandler(int signal){
	if(id != 0)	kill(id,SIGTERM);
}

//return 0 if it is not build in command
int bool_build_in(const char* command){
	if(strcmp(command,"cd") == 0)	return 1;
	else if(strcmp(command,"!history") == 0) return 2;
	else if(strncmp(command,"!",1) == 0)	return 3;
	else if(strncmp(command,"#",1) == 0)	return 4; //&& command[1]!=NULL && isdigit(command[1])
	else if(strncmp(command,"ps",2) == 0)	return 5;
	else if(strcmp(command,"kill") == 0)	return 7;
	else if(strcmp(command,"stop") == 0)	return 8;
	else if(strcmp(command,"cont") == 0)	return 9;
	
	return 0;	 
}

void cleanUp(int s){
	pid_t p;
	int status;
	while((p=waitpid(-1,&status,WNOHANG))>0){
		for(size_t i = 0; i < vector_size(histroy_string); i++){
			process* temp = vector_get(history_string,i);
			if(temp->pid == p)	vector_erase(history_string,i);
		}
	}
}

//return 0 if there is no & at the end
int background_check(char** object){
	int k = 0;
	while(object[k]!=NULL) k++;
	if(object[k-1] == "&" || ((object[k-1][(strlen(object[k-1])-1)] == '&') && (object[k-1][(strlen(object[k-1])-2)] != '\\')))	
}	return 0;
}

int shell(int argc, char *argv[]) {
    // TODO: This is the entry point for your shell.
	if(argc<2){
		print_usage();
		fflush(stdout);
		return 0;
	}

//deal with ctrl + c
	signal(SIGINT, INThandler);	

//create universal 	
	history_string = process_vector_create();
	process* lj;
	pid_t mainid = getpid();

	
	

//start from file
	int c_t = 0;
	int temp = getopt(argc,argv,"fh");

	if(temp!=-1){
	while(temp!=-1){
		if(temp == 'f'){
			c_t ++;
			if(argv[2*c_t] == NULL && strncmp(argv[2*c_t],"-",1)==0){
				print_usage_error();
				fflush(stdout);
				exit(1);
			}
			char* file_name = argv[2*c_t];
			FILE* file_t = fopen(file_name,"r"); 
			if(file_t == NULL){
				print_script_file_error();
				fflush(stdout);
				exit(1);
			}



			char* file_buffer = NULL;
			size_t num;
			ssize_t read = 0;
			while(read = getline(&file_buffer, &num,file_t)!= -1){
			
			
//get command ( command  is like "cd" and object is "cd", "cs241") file_buffer is the whole thing
			char* command;
			char** object = malloc(1024);
			command = strtok(file_buffer," ");
			int i = 0;
			while(command != NULL){
				object[i] = command;
				i++;
				command = strtok(NULL," ");
			}
			command = object[0];

//first print the command line
			char* temp = getcwd(NULL,0);
                        print_prompt(temp,mainid);
			print_commnad(file_buffer);
                        fflush(stdout);
                        free(temp);

//exit case
			if(strcmp(command,"exit") == 0){
				if(i!=1){
					print_invalid_command(command);
					fflush(stdout);
				}
				else{
					free(file_buffer);
					free(object);
					fclose(file_t);
					vector_destroy(history_string);
					history_string = NULL;
					exit(0);
				}
			}

//TO see if it is external or build in
			int check = bool_build_in(command);	
			if(check != 0){
				int cc = build_in_commands(object,check,i);
				if((check != 2) && (check!=3) && (check!=4)){
					lj->command = command;
					lj->status = "STATUS_RUNNING";
					lj->pid = getpid();
					vector_push_back(history_string, lj);
				}
// whether if needs to push into vector    
			}
			else {
//(still needing operator check for external command)
			id = fork();
			if(id == -1){
				print_fork_failed();
				fflush(stdout);
				exit(1);
			   }
			else if(id > 0){
				int status;
				pid_t pid = waitpid(id,&status,0);
				if(pid!=-1 && WIFEXITED(status)){
					int exit_status = WEXITSTATUS(status);
                                if(exit_status != 0){
					print_wait_failed();
					fflush(stdout);
                                       	exit(1);
                          	}	
			    }
			  }
			else{	
				print_command_executed(id);
				fflush(stdout);
				lj->command = command;
				lj->status = "STATUS_RUNNING";
				lj->pid = id;
				vector_push_back(history_string,lj);
				execvp(file_buffer,&file_buffer);
				print_exec_failed(file_buffer);
				fflush(stdout);	
				exit(1);
			   }
		        }

		    }//end read for 'f'
                }
		else if(temp == 'h'){
			c_t ++;
//argv[c_t * 2] is the file 
			if(argv[c_t*2] ==NULL && strncmp(argv[c_t*2],"-",1) == 0){
				print_usage_error();
				fflush(stdout);
				exit(1);		
			}
			char* path = get_full_path(argv[c_t*2]);
			if(path == NULL){
				print_history_file_error();
				fflush(stdout);
				exit(1);
			}
			char* file_buffer1 = NULL;
			size_t num1;
			ssize_t read1 = 0;
			FILE* file_t1 = fopen(argv[(int)c_t*2],"w+"); 
			while(read1 = getline(&file_buffer1, &num1,file_t1) != -1){
				lj->command = file_buffer1;
				lj->status = NULL;
				lj->pid = -1;
				vector_push_back(history_string,lj);
			}
//save so we get to rewrite it
			file_saving = argv[c_t*2];
		}
// see if there is more than one '-'
		temp = getopt(argc,argv,"fh");
            }
	}
	else {
//start to take stdin till end of file
	FILE* fil = stdin;
	char* file_buffer1 = NULL;
	size_t num1;
	ssize_t read1 = 0;
	while(read_1 = getline(&file_buffer1, &num1,fil)){
		char* command;
		char** object = malloc(1024);
		command = strtok(file_buffer1," ");
		int i = 0;
		while(command != NULL){
			object[i] = command;
			i++;
			command = strtok(NULL," ");
		}
		command = object[0];
//exit case
		if(strcmp(command,"exit") == 0){
				if(i!=1){
					print_invalid_command(command);
					fflush(stdout);
				}
				else{
					free(command);
					free(object);
					vector_destroy(history_string);
					history_string = NULL;
					exit(0);
				}
		}

//evaluate also include the logical operator

//build_in first
	int key = bool_build_in(command);
	if(key!=0){
		char* temp = getcwd(NULL,0);
                print_prompt(temp,mainid);
		print_commnad(file_buffer);
                fflush(stdout);
                free(temp);
		int out = build_in_commands(object,key,i);
		if((check != 2) && (check!=3) && (check!=4)){
					lj->command = command;
					lj->status = "STATUS_RUNNING";
					lj->pid = getpid();
					vector_push_back(history_string, lj);
				}
	}
//external command
	else{
	int k = 0;
	int c = 0;
	int gg = 0;
	while(object[k]!=NULL){
		if((strcmp(object[k],"&&")==0) && (strcmp(object[k],";")==0) && (strcmp(object[k],"||")==0)){
			gg = k;		
			break;
		}
		k++;
	}

//special  /&&
	while(object[c]!=NULL){
		if(strcmp(object[c],"\&\&")==0){
			object[c] = "&&";
		}else if(strcmp(object[c],"\;")==0){
			object[c] = ";";
		}else if(strcmp(object[c],"\|\|")==0)){
			object[c] = "||";	
		}
		c++;
	}
	if(gg = 0){
		id = fork();
			if(id == -1){
				print_fork_failed();
				fflush(stdout);
				exit(1);
			   }
			else if(id > 0){
				int status;
				pid_t pid = waitpid(id,&status,0);
				if(pid!=-1 && WIFEXITED(status)){
					int exit_status = WEXITSTATUS(status);
                                if(exit_status != 0){
					print_wait_failed();
					fflush(stdout);
                                       	exit(1);
                          	}	
			    }
			  }
			else{	
				print_command_executed(id);
				fflush(stdout);
				lj->command = command;
				lj->status = "STATUS_RUNNING";
				lj->pid = id;
				vector_push_back(history_string,lj);
				execvp(file_buffer,&file_buffer);
				print_exec_failed(file_buffer);
				fflush(stdout);	
				exit(1);
			   }
	}
	else{
		char** front;
		char** back;
	lj->command = command;
	lj->status = "STATUS_RUNNING";
	lj->pid = getpid();
	vector_push_back(history_string,lj);

	for(size_t i = 0 ; i < gg; i++){
		front[i] = object[i];
	}
	k = 0;
	while(object[gg+1+k]!=NULL){
		back[k] = object[gg+1+k];
	}
//get the two long command
	size_t ini = 1;
	char* given = front[0];
	while(front[ini]!=NULL){
		strcat(given," ");
		strcat(given,front[ini]);
		ini++;
		}
	id = fork();
	if(id == -1){
		print_fork_failed();
		fflush(stdout);
		exit(1);
		  }
	else if(id > 0){
		int status_1;
		pid_t pid_1 = waitpid(id,&status,0);
		if(pid_1!=-1 && WIFEXITED(status_1)){
		int exit_status_1 = WEXITSTATUS(status_1);
                if(exit_status_1 != 0){
			print_wait_failed();
			fflush(stdout);
			flag = 0;
                        exit(1);
                        }	
		}
	}
	else{	
		print_command_executed(id);
		fflush(stdout);
		execvp(given,&given);
		print_exec_failed();
		fflush(stdout);
		exit(1);
	}

	ini = 1;
	char* given_1 = back[0];
	while(back[ini]!=NULL){
		strcat(given_1," ");
		strcat(given_1,back[ini]);
		ini++;
		}

//check what special operator is there
	if(strcmp(object[gg],"&&")==0){
		if(flag){
			if(id == -1){
		print_fork_failed();
		fflush(stdout);
		exit(1);
		  }
	else if(id > 0){
		int status_1;
		pid_t pid_1 = waitpid(id,&status,0);
		if(pid_1!=-1 && WIFEXITED(status_1)){
		int exit_status_1 = WEXITSTATUS(status_1);
                if(exit_status_1 != 0){
			print_wait_failed();
			fflush(stdout);
			flag = 0;
                        exit(1);
                        }	
		}
	}
	else{	
		print_command_executed(id);
		fflush(stdout);
		execvp(given_1,&given_1);
		print_exec_failed();
		fflush(stdout);
		exit(1);
	}	
		}
	
	}
		
	else if(strcmp(object[gg],"||")==0){
		if(!flag){
			if(id == -1){
		print_fork_failed();
		fflush(stdout);
		exit(1);
		  }
	else if(id > 0){
		int status_1;
		pid_t pid_1 = waitpid(id,&status,0);
		if(pid_1!=-1 && WIFEXITED(status_1)){
		int exit_status_1 = WEXITSTATUS(status_1);
                if(exit_status_1 != 0){
			print_wait_failed();
			fflush(stdout);
			flag = 0;
                        exit(1);
                        }	
		}
	}
	else{	
		print_command_executed(id);
		fflush(stdout);
		execvp(given_1,&given_1);
		print_exec_failed();
		fflush(stdout);
		exit(1);
	}

		}
	}
		
	else{
		if(id == -1){
		print_fork_failed();
		fflush(stdout);
		exit(1);
		  }
	else if(id > 0){
		int status_1;
		pid_t pid_1 = waitpid(id,&status,0);
		if(pid_1!=-1 && WIFEXITED(status_1)){
		int exit_status_1 = WEXITSTATUS(status_1);
                if(exit_status_1 != 0){
			print_wait_failed();
			fflush(stdout);
			flag = 0;
                        exit(1);
                        }	
		}
	}
	else{	
		print_command_executed(id);
		fflush(stdout);
		execvp(given_1,&given_1);
		print_exec_failed();
		fflush(stdout);
		exit(1);
	}
      }
    }//small else 
   }// big while
	char* temp = getcwd(NULL,0);
        print_prompt(temp,mainid);
        fflush(stdout);
        free(temp);
  }//big else 
    return 0;
}

/**
* Text Editor Lab
* CS 241 - Spring 2018
*/

#include "document.h"
#include "editor.h"
#include "format.h"
#include "sstream.h"

#include <assert.h>
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CSTRING(x) ((bytestring){(char *)x, -1})
#define DECLARE_BUFFER(name) bytestring name = {NULL, 0};
#define EMPTY_BYTES ((bytestring){NULL, 0})

char *get_filename(int argc, char *argv[]) {
    // TODO implement get_filename
    // take a look at editor_main.c to see what this is used for
    //OK
    if(argc < 2){
      print_usage_error();
      return NULL;
    }
    char * f = (char*)malloc(strlen(argv[1])+1);
    strcpy(f, argv[1]);
    return f;
}

sstream *handle_create_stream() {
    // TODO create empty stream
    return sstream_create(EMPTY_BYTES);;
}

document *handle_create_document(const char *path_to_file) {
    // TODO create the document
    //OK
    document * doc = document_create_from_file(path_to_file);
    return doc;
}

void handle_cleanup(editor *editor) {
    // TODO destroy the document
    //OK
    document_destroy(editor->document);
}

void handle_display_command(editor *editor, size_t start_line,
                            ssize_t max_lines, size_t start_col_index,
                            ssize_t max_cols) {
    // TODO implement handle_display_command
    //OK
    assert(start_line >= 1);
    if((ssize_t)document_size(editor->document)<=0 || editor->document == NULL){
		    print_document_empty_error();
	      return;
	  }
	  if(max_lines == -1){
      for(size_t i = start_line; i <= document_size(editor->document); i++){
			     print_line(editor->document, i, start_col_index, max_cols);
		  }
	  }
	  else{
		    size_t sz;
		    if((size_t)max_lines < document_size(editor->document))	sz = max_lines;
		    else sz = document_size(editor->document) - 1;
		    for(size_t j = start_line; j <= sz; j++){
			       print_line(editor->document, j, start_col_index, max_cols);
		    }
	  }
}

void handle_insert_command(editor *editor, location loc, const char *line) {
    // TODO implement handle_insert_command
    // size_t line_number = loc.line_no;
    // size_t index = loc.idx;
    // if(line == NULL) return;
    // if(line_number > document_size(editor->document)){
		//     document_insert_line(editor->document, line_number, line);
		//     return;
	  // }
    // char* orig = (char*)document_get_line(editor->document,line_number);
  	// char* str = malloc(strlen(orig) + strlen(line) + 1);
  	// strncpy(str, orig, index);
  	// str[index] = '\0';
  	// strcat(str, line);
  	// strcat(str, orig + index);
  	// document_delete_line(editor->document, line_number);
  	// document_insert_line(editor->document, line_number, str);
  	// free(str);
    // str = NULL;
    // OK
    if(line == NULL) return;
	  if(loc.line_no <= document_size(editor->document) && loc.line_no >= 1){
    		int capacity = strlen(line) + strlen(document_get_line(editor->document, loc.line_no)) + 1;
        char *old = (char*)document_get_line(editor->document, loc.line_no);
    		char *new = (char*)malloc(capacity);
    		int i = 0;
    		while(i < capacity - 1){
      			while(i < (int)loc.idx){
        				new[i] = *old;
                i++;
                old++;
            }
      			while(i < (int)(loc.idx + strlen(line))){
                new[i] = *line;
                i++;
                line++;
            }
    			  new[i] = *old;
            i++;
            old++;
    		}
    		new[i] = '\0';
    		document_set_line(editor->document, loc.line_no, new);
    		free(new);
    		new = NULL;
  	}
  	else if(loc.line_no > document_size(editor->document) && loc.line_no >= 1){
    		for(int i = document_size(editor->document) + 1; i <= (int)loc.line_no - 1; i++){
    			  document_insert_line(editor->document, i, "");
        }
    		document_insert_line(editor->document, loc.line_no, line);
  	}
}

void handle_append_command(editor *editor, size_t line_no, const char *line) {
    // TODO implement handle_append_command
    // OK
    if(line_no > document_size(editor->document))
		    document_insert_line(editor->document, line_no, line);
	  else{
    		  char* old =  (char*)document_get_line(editor->document, line_no);
      		old += strlen(old);
      		while(*line){
        			if((*line == '\\')&&(line[1] == '\0')){
          				line++;
        			}
        			else if(*line == '\n'){
          				*old = '\\';
          				old++;
          				line++;
        			}
        			else{
            			*old = *line;
            			old++;*old = *line;
        			old++;
        			line++;
            			line++;
        			}
      	}
    		*old = '\0';
    }
}

void handle_write_command(editor *editor, size_t line_no, const char *line) {
    // TODO implement handle_write_command
    // OK
    if(line_no > document_size(editor->document))
  		  document_insert_line(editor->document, line_no, line);
  	else{
    		char* old = (char*)document_get_line(editor->document, line_no);
    		while(*line){
      			if((*line == '\\')&&(line[1] == '\0')){
      				    line++;
      			}
      			else if(*line == '\n'){
        				*old = '\\';
        				old++;
        				line++;
      			}
      			else{
        			*old = *line;
        			old++;
        			line++;
      			}
    		}
    		if(*old) old[0] = '\0';
  	}
}

void handle_delete_command(editor *editor, location loc, size_t num_chars) {
    // TODO implement handle_delete_command'
    // OK
    char* line = (char*)document_get_line(editor->document, loc.line_no);
  	if(strlen(line) - loc.idx <= num_chars){
  		  line[loc.idx] = '\0';
  	}else{
    		line += loc.idx;
    		while(line[num_chars]){
      			*line = line[num_chars];
      			line++;
    		}
    		*line = '\0';
  	}
}

void handle_delete_line(editor *editor, size_t line_no) {
    // TODO implement handle_delete_line
    //Ok
    if(line_no <= document_size(editor->document))  document_delete_line(editor->document, line_no);
}

location handle_search_command(editor *editor, location loc,
                               const char *search_str) {
    // TODO implement handle_search_command
    //search_str doesn't exist
    // OK
    size_t line_number = loc.line_no;
    size_t index = loc.idx;
    if(*search_str == '\0') return (location){0, 0};
  	if(line_number > document_size(editor->document)) return (location){0, 0};
  	char * line = (char*)document_get_line(editor->document, line_number);
  	if(strlen(search_str) > (strlen(line)-index)) return (location){0, 0};
    int check = 1;
  	line += index;
  	int new_idx = 0;
  	while(line[new_idx]){
  		  if(line[new_idx] == search_str[0]){
  			     for(size_t i = 1; i < strlen(search_str);i++){
  			          if(check!=1)   break;
  			          else {
  					             if(line[new_idx+i] != search_str[i])
  					             check = 0;
  			         }
  			     }
      			 if (check == 1) {
                  location loc =  (location){line_number,index+new_idx};
                  return loc;
             }
  		  }
  	check = 1;
  	new_idx += 1;
  	}
    //not found here
  	return (location){0, 0};
}

void handle_merge_line(editor *editor, size_t line_no) {
    // TODO implement handle_merge_line
    //OK
    char *old = (char*)document_get_line(editor->document, line_no);
  	char *new = (char*)document_get_line(editor->document, line_no + 1);//need realloc?
  	char *in = (char*)malloc(sizeof(char) * (strlen(old) + strlen(new) + 1));
  	strcpy(in, old);
  	strcat(in, new);
  	document_set_line(editor->document, line_no, in);
  	document_delete_line(editor->document, line_no + 1);
  	free(in);
}

void handle_split_line(editor *editor, location loc) {
    // TODO implement handle_split_line
    //OK
    char *old = (char*)document_get_line(editor->document, loc.line_no);
  	int length = strlen(old) - loc.idx + 1;
  	char *new = (char*)malloc(sizeof(char) * length);
  	int i = 0;
  	char *temp = old;
  	temp += loc.idx;
  	while(i < length - 1){
    		new[i++] = *temp;
    		*temp = '\0';
    		temp++;
  	}
  	new[i] = '\0';
  	document_insert_line(editor->document, loc.line_no + 1, new);
  	free(new);
  	new = NULL;
}

void handle_save_command(editor *editor) {
    // TODO implement handle_save_command
    //OK
    document_write_to_file(editor->document, editor->filename);
}

/**
* Text Editor Lab
* CS 241 - Spring 2018
*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include "document.h"
#include "vector.h"

struct document {
    vector *vector;
};

document *document_create() {
    document *this = (document *)malloc(sizeof(document));
    assert(this);
    this->vector = vector_create(string_copy_constructor, string_destructor,
                                 string_default_constructor);
    return this;
}

void document_write_to_file(document *this, const char *path_to_file) {
    assert(this);
    assert(path_to_file);
    // see the comment in the header file for a description of how to do this!
    // TODO: your code here!
	// int fildes = open(path_to_file, O_CREAT|O_TRUNC|O_RDWR, S_IRUSR|S_IWUSR);
	// size_t lines = document_size(this);
	// for(size_t i = 1; i < lines+1; i++){
	// 	write(fildes,document_get_line(this, i),sizeof(char)*strlen(document_get_line(this,i))+1);
	// 	write(fildes,"\n",1);
	// }
	// close(fildes);
  FILE * file = fopen(path_to_file,"W");
  struct vector *v = this->vector;
  for(int i = 0; i <= (int) vector_size(v); i +)
    fprintf(file, "%s\n",vecotr_get(v,i-1));
  fclose(file);
}

document *document_create_from_file(const char *path_to_file) {
    assert(path_to_file);
    // this function will read a file which is created by document_write_to_file
    // TODO: your code here!
	document* result = document_create();
	FILE* file = fopen(path_to_file,"r+");
	if(file==NULL)	return result;
	size_t initial = 1;
	char *buffer = NULL;
	size_t bufsize = 0;
	while(1){
		if(getline(&buffer,&bufsize,file) == -1) break;
		buffer[strlen(buffer)+1] = '\0';
		document_set_line(result, initial, buffer);
		initial++;
	}
	free(buffer);
	fclose(file);
	return result;

}

void document_destroy(document *this) {
    assert(this);
    vector_destroy(this->vector);
    free(this);
}

size_t document_size(document *this) {
    assert(this);
    return vector_size(this->vector);
}

void document_set_line(document *this, size_t line_number, const char *str) {
    assert(this);
    assert(str);
    size_t index = line_number - 1;
    vector_set(this->vector, index, (void *)str);
}

const char *document_get_line(document *this, size_t line_number) {
    assert(this);
    assert(line_number > 0);
    size_t index = line_number - 1;
    return (const char *)vector_get(this->vector, index);
}

void document_insert_line(document *this, size_t line_number, const char *str) {
    assert(this);
    assert(str);
    // TODO: your code here!
    // How are you going to handle the case when the user wants to
    // insert a line past the end of the document?
	// if (str == NULL)	return;
	// if (line_number > document_size(this)){
	// 	size_t num_btwn;
	// 	for(num_btwn = 1; num_btwn < (line_number - document_size(this)); num_btwn++){
	// 		const char * in = "";
	// 		document_set_line(this, document_size(this)+num_btwn, in);
	// 	}
	// 	document_set_line(this, line_number, str);
	// 	return;
	// }
	// const char* line = document_get_line(this, line_number);
	// document_set_line(this, line_number, str);
	// line_number++;
	// document_insert_line(this,line_number,line);
  if(line_number>vector_capacity(this->vector))
    vector_reserve(this->vector,line_number);
  vector_insert(this->vector, line_number-1, (void*)str);
}

void document_delete_line(document *this, size_t line_number) {
    assert(this);
    assert(line_number > 0);
    size_t index = line_number - 1;
    vector_erase(this->vector, index);
}

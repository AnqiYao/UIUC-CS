/**
* Shell Lab
* CS 241 - Spring 2018
*/

#include "format.h"
#include "shell.h"
#include "vector.h"
#include <unistd.h>
#include <stdio.h>
#include <string.h>

typedef struct process {
    char *command;
    char *status;
    pid_t pid;
} process;

//return -1 if the build in command cannot be done
int build_in_commands(const char* command, const char** object){
	if(str)		
	fflush(stdout);
}

//return 1 if it is build in command
int bool_build_in(const char* command){
	if(strcmp(command,"cd") == 0)	return 1;
	else if(strcmp(command,"!history") == 0) return 1;
	else if(strncmp(command,"!",1) == 0)	return 1;
	else if(strncmp(command,"#",1) == 0 && command[1]!=NULL && isdigit(command[1]))	return 1;
	else if(strncmp(command,"ps",2) == 0)	return 1;
	else if(strcmp(command,"exit") == 0)	return 1;
	else if((strcmp(command,"kill") == 0)| (strcmp(command,"stop") == 0)| (strcmp(command,cont) == 0))	return 1;
	
	return 0;	 
}

int shell(int argc, char *argv[]) {
    // TODO: This is the entry point for your shell.
	if(argc<2){
		print_usage();
		exit(1);
	}

//start
	int temp = getopt(argc,argv,"fh");
	while(temp!=-1){
		if(temp == 'f'){
			char* file_name = argv[2];
			FILE* file_t = fopen(file_name,"r"); 
			if(file_t == NULL){
				print_script_file_error();
				fflush(stdout);
				exit(1);
			}
			char* file_buffer = NULL;
			size_t num;
			ssize_t read = 0;
			while(read = getline(&file_buffer, &num,file_t)!= -1){
			char* command;
			char** object = malloc(1024);
			command = strtok(file_buffer," ");
			int i = 0;
			while(command != NULL){
				object[i] = command;
				i++;
				command = strtok(NULL," ");
			}
			command = object[0];
			int check = bool_build_in(command);	
			if(check == 1){
				int check_t = build_in_commands(command,object);
				if(check_t == 0)
				read = getline(&file_buffer, &num, file_t);	
				break;
			}
			else {
			pid_t id = fork();
			if(id == -1){
				print_fork_failed();
				exit(1);
			   }
			else if(id > 0){
				int status;
				pid_t pid = waitpid(id,&status,0);
				if(pid!=-1 && WIFEXITED(status)){
					int exit_status = WEXITSTATUS(status);
                                if(exit_status != 0){
                                       	exit(1);
                          	}	
			    }
			  }
			else{	
				char* temp = getcwd(NULL,0);
				print_prompt(temp,id);
				print_command(file_buffer);
				free(temp);
				execvp(file_buffer,&file_buffer);
				print_exec_failed();
				fflush(stdout);	
				exit(1);
			   }
		        }
		    }
                }
		
			else if(strcmp(argv[num],"-h")){
				return 1;
			}
		}
		else if(temp == 'h'){
			pid_t id = fork();
			if(id == -1){
				print_fork_failed();
				fflush();
				exit(1);
			}
			else if(id == 0)
			else{
				return 1;
			}
		}
		else if(temp == '?'){
			return 1;
		}
		temp = getopt(argc,argv,"fh");
	}
    return 0;
}

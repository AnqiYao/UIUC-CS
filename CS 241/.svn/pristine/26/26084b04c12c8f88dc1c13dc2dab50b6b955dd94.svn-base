/**
* Shell Lab
* CS 241 - Spring 2018
*/

#include "format.h"
#include "shell.h"
#include "vector.h"
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/wait.h>

typedef struct process {
    char *command;
    char *status;
    pid_t pid;
} process;

static vector* process_file;
static vector* history_string;
static pid_t id = 0;

void* process_copy_constructor(void*elem){
	process* newone = calloc(1,sizeof(process));
	process* oldone = (process*)elem;
	char* newCm;
	char* newSt;


	if (oldone->command != NULL)
	{
		newCm = strdup(oldone->command);
	}
	else
		newCm = NULL;
	if (oldone->status != NULL)
	{
	    newSt = strdup(oldone->status);
	}
	else
		newSt = NULL;
	newone->command = newCm;
	newone->status = newSt;
	newone->pid = oldone->pid;
	return newone;process* newone = calloc(1,sizeof(process));
	process* oldone = (process*)elem;
	char* newCm;
	char* newSt;


	if (oldone->command != NULL)
	{
		newCm = strdup(oldone->command);
	}
	else
		newCm = NULL;
	if (oldone->status != NULL)
	{
	    newSt = strdup(oldone->status);
	}
	else
		newSt = NULL;
	newone->command = newCm;
	newone->status = newSt;
	newone->pid = oldone->pid;
	return newone;process* newone = calloc(1,sizeof(process));
	process* oldone = (process*)elem;
	char* newCm;
	char* newSt;


	if (oldone->command != NULL)
	{
		newCm = strdup(oldone->command);
	}
	else
		newCm = NULL;
	if (oldone->status != NULL)
	{
	    newSt = strdup(oldone->status);
	}
	else
		newSt = NULL;
	newone->command = newCm;
	newone->status = newSt;
	newone->pid = oldone->pid;
	return newone;	
}

void process_destructor(void* elem){
	if(elem == NULL)  	return;
  	process* oldone = (process*)elem;

	if (oldone->command != NULL)
		{
			free(oldone->command);
		}
	if (oldone->status != NULL)
	{
		free(oldone->status);
	}
	free(oldone);
  return;
}

void *process_default_constructor(void) { return calloc(1,sizeof(process)); }

vector *process_vector_create() {
return vector_create(process_copy_constructor, process_destructor,
                       process_default_constructor);
}

//return -1 if the build in command cannot be done
int build_in_commands(const char** object,int check,int count){
	if (check == 1){
		if(count>2 ){
			print_invalid_command(object[0]);
			fflush(stdout);
	 		return -1;	
		}
		if(count = 1){
			print_no_directory(NULL);
			fflush(stdout);
			return -1;
		}
		char* temp = NULL;
		if(strncmp(object[1],"/",1) !=0){
			temp = getcwd(NULL,0); 
	        	strcat(temp,"/");
			strcat(temp,object[1]);
		}
		else{
			temp = object[1];	
		}
		int temp1 = chdir(temp);
		if(temp1 == -1)	{
			print_no_directory(temp);
			fflush(stdout);
			return -1;
		}
	}else if(check == 2){
		size_t cur = 0;
		vector* help;
		while(cur < vector_size){
			help = vector_get(history_string, cur);
			print_history_line(cur,help->command);
			fflush(stdout);
			cur++;
		return 0;
		}
	}else if(check == 3){
		return 0;	
			
	}else if(check == 4){
		return 0;
	}else if(check == 5){
		return 0;	
	}else if(check == 6){
		return 0;
	}else if(check == 7){
		return 0;
	}	
}

void INThandler(int signal){
	if(id != 0)	kill(id,SIGTERM);
}

//return 0 if it is not build in command
int bool_build_in(const char* command){
	if(strcmp(command,"cd") == 0)	return 1;
	else if(strcmp(command,"!history") == 0) return 2;
	else if(strncmp(command,"!",1) == 0)	return 3;
	else if(strncmp(command,"#",1) == 0 && command[1]!=NULL && isdigit(command[1]))	return 4;
	else if(strncmp(command,"ps",2) == 0)	return 5;
	else if(strcmp(command,"exit") == 0)	return 6;
	else if((strcmp(command,"kill") == 0)| (strcmp(command,"stop") == 0)| (strcmp(command,cont) == 0))	return 7;
	
	return 0;	 
}

int shell(int argc, char *argv[]) {
    // TODO: This is the entry point for your shell.
	if(argc<2){
		print_usage();
		fflush(stdout);
		exit(1);
	}
	
	signal(SIGINT, INThandler);	
	
	process_file = process_vector_create();
	history_string = process_vector_create();
	process* lj;
	process* mmp;
//start
	pid_t mainid = getpid();
	double c_t = 0;
	int temp = getopt(argc,argv,"fh");
	if(temp!=-1){
	while(temp!=-1){
		if(temp == 'f'){
			c_t ++;
			if(argv[(int)2*c_t] == NULL && strncmp(argv[(int)2*c_t],"-",1)==0){
				print_usage_error();
				fflush(stdout);
				exit(1);
			}
			char* file_name = argv[(int)2*c_t];
			FILE* file_t = fopen(file_name,"r"); 
			if(file_t == NULL){
				print_script_file_error();
				fflush(stdout);
				exit(1);
			}
			char* file_buffer = NULL;
			size_t num;
			ssize_t read = 0;
			while(read = getline(&file_buffer, &num,file_t)!= -1){
			
			char* command;
			char** object = malloc(1024);
			command = strtok(file_buffer," ");
			int i = 0;
			while(command != NULL){
				object[i] = command;
				i++;
				command = strtok(NULL," ");
			}
			command = object[0];
			char* temp = getcwd(NULL,0);
                        print_prompt(temp,mainid);
                        print_commnad(command);
                        fflush(stdout);
                        free(temp);
			lj->status = STATUS_RUNNING;
			lj->pid = getpid();
			lj->command = file_buffer;
			int check = bool_build_in(command);	
			if(check != 0){
				int cc = build_in_commands(object,check,i);
				vector_push_back(process_file, lj);
			}
			else {
			id = fork();
			if(id == -1){
				print_fork_failed();
				exit(1);
			   }
			else if(id > 0){
				int status;
				pid_t pid = waitpid(id,&status,0);
				if(pid!=-1 && WIFEXITED(status)){
					int exit_status = WEXITSTATUS(status);
                                if(exit_status != 0){
					print_wait_failed();
                                       	exit(1);
                          	}	
			    }
			  }
			else{	
				
				print_command_executed(id);
				fflush(stdout);
				lj->pid = id;
				vector_push_back(process_file,lj);
				execvp(file_buffer,&file_buffer);
				print_exec_failed(file_buffer);
				fflush(stdout);	
				exit(1);
			   }
		        }

		    }//end read 
                }
		else if(temp == 'h'){
			c_t ++;
			if(argv[(int)c_t*2] ==NULL && strncmp(argv[(int)c_t*2],"-",1) == 0){
				print_usage_error();
				fflush(stdout);
				exit(1);		
			}
			char* path = get_full_path(argv[(int)c_t*2]);
			if(path == NULL){
				print_history_file_error();
				fflush(stdout);
				exit(1);
			}
			char* file_buffer1 = NULL;
			size_t num1;
			ssize_t read1 = 0;
			FILE* file_t1 = fopen(argv[(int)c_t*2],"w+"); 
			while(read = getline(&file_buffer1, &num1,file_t1) != -1){
				mmp->command = file_buffer1;
				mmp->status = NULL;
				mmp->pid = -1;
				vector_push_back(history_string,mmp);
			}
						
		}
		temp = getopt(argc,argv,"fh");
            }
	}
	else {
	int key = bool_build_in(argv[1]);
	char** res = malloc(256);
	char* point = res;
	int k = 1;
	int count_1 = 0;
	int isok = 1;
	while(argv[k]!=NULL && isok){
		while(strcmp(argv[k],"&&")!=0 && strcmp(argv[k],";")!=0 && argv[k]!=NULL){
			res[k-1] = argv[k];
			k++;
			count_1 ++;
		}
		int ini = 1;
		char* given = res[0];
		while(res[ini]!=NULL){
			strcat(given," ");
			strcat(given,res[ini]);
		}
		if(key != 0){
			int cc = build_in_commands(res,key,count_1);
			if(strcmp(argv[k],"&&")==0)	isok = cc;
			char* temp2 = getcwd(NULL,0);	
			print_prompt(temp2, mainid);
			fflush(stdout);
		}
		else {
			id = fork();
			if(id == -1){
				print_fork_failed();
				isok = 0;
				exit(1);
			   }
			else if(id > 0){
				int status_1;
				pid_t pid_1 = waitpid(id,&status,0);
				if(pid_1!=-1 && WIFEXITED(status_1)){
					int exit_status_1 = WEXITSTATUS(status_1);
                                if(exit_status_1 != 0){
					print_wait_failed();
					isok = 0;
                                       	exit(1);
                          	}	
			    }
			  }
			else{	
				
				print_command_executed(id);
				fflush(stdout);
				execvp(given,&given);
				print_exec_failed();
				fflush(stdout);	
				isok = 0;
				exit(1);
			   }
		}
		if(argv[k]!=NULL){
			res +=k;
			key = bool_build_in(argv[k+1]);
			count_1 = 0;
		}			
	}	
		free(point);
	}
	
    return 0;
}

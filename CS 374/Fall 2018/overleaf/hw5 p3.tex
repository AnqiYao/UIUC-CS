% ---------
%  Compile with "pdflatex hw4".
% --------
%!TEX TS-program = pdflatex
%!TEX encoding = UTF-8 Unicode

\documentclass[11pt]{article}
\usepackage{jeffe,handout,graphicx}
\usepackage[utf8]{inputenc}		% Allow some non-ASCII Unicode in source
\graphicspath{ {./Images/} }
%  Redefine suits
\usepackage{pifont}
\def\Spade{\text{\ding{171}}}
\def\Heart{\text{\textcolor{Red}{\ding{170}}}}
\def\Diamond{\text{\textcolor{Red}{\ding{169}}}}
\def\Club{\text{\ding{168}}}

\def\Cdot{\mathbin{\text{\normalfont \textbullet}}}
\def\Sym#1{\textbf{\texttt{\color{BrickRed}#1}}}



% =====================================================
%   Define common stuff for solution headers
% =====================================================
\Class{CS/ECE 374}
\Semester{FALL $2018$}
\Authors{3}
\AuthorOne{Zhe Zhang}{zzhan157@illinois.edu}
\AuthorTwo{Ray Ying}{xinruiy2@illinois.edu}
\AuthorThree{Anqi Yao}{anqiyao2@illinois.edu}
%\Section{}
% =====================================================
\documentclass[12pt]{article}
\usepackage{tikz}
\begin{document}

% ---------------------------------------------------------

\HomeworkHeader{$5$}{$3$}
\begin{enumerate}
 \item Recall that a \emph{palindrome} is any string that is exactly
  the same as its reversal, like \Sym{I}, or \Sym{DEED}, or
  \Sym{RACECAR}, or \Sym{AMANAPLANACATACANALPANAMA}. For technical
  reasons, in this problem, we will only be interested in palindromes
  that are of length at least one, hence we will
  not treat the string $\epsilon$ as a palindrome.

Any string can be decomposed into a sequence of palindrome substrings.  For example, the string \Sym{BUBBASEESABANANA} (“Bubba sees a banana.”\@) can be broken into palindromes in the following ways (among many others):
\begin{gather*}
	\Sym{BUB} \Cdot \Sym{BASEESAB} \Cdot \Sym{ANANA}\\
	\Sym{B} \Cdot \Sym{U} \Cdot \Sym{BB} \Cdot \Sym{A} \Cdot \Sym{SEES} \Cdot \Sym{ABA} \Cdot \Sym{NAN} \Cdot \Sym{A}\\
	\Sym{B} \Cdot \Sym{U} \Cdot \Sym{BB} \Cdot \Sym{A} \Cdot \Sym{SEES} \Cdot \Sym{A} \Cdot \Sym{B} \Cdot \Sym{ANANA}\\
	\Sym{B} \Cdot \Sym{U} \Cdot \Sym{B} \Cdot \Sym{B} \Cdot
        \Sym{A} \Cdot \Sym{S} \Cdot \Sym{E} \Cdot \Sym{E} \Cdot
        \Sym{S} \Cdot \Sym{A} \Cdot \Sym{B} \Cdot \Sym{ANA}  \Cdot
        \Sym{N} \Cdot \Sym{A}\\
        	\Sym{B} \Cdot \Sym{U} \Cdot \Sym{B} \Cdot \Sym{B}
                \Cdot \Sym{A} \Cdot \Sym{S} \Cdot \Sym{E} \Cdot
                \Sym{E} \Cdot \Sym{S} \Cdot \Sym{A} \Cdot \Sym{B}
                \Cdot \Sym{A} \Cdot \Sym{N} \Cdot \Sym{A}  \Cdot \Sym{N} \Cdot \Sym{A}
\end{gather*}

Since any string $w \neq \epsilon$ can always be decomposed to palindromes we
may want to find a decomposition that optimizes some objective. Here
are two example objectives. The first objective is to decompose $w$ into the
smallest number of palindromes. A second objective is to find a
decomposition such that each palindrome in the decomposition has
length at least $k$ where $k$ is some given input parameter. Both of
these can be cast as special cases of an abstract problem. Suppose we
are given a function called $cost()$ that takes a positive integer $h$
as input and outputs an integer $\cost(h)$.  Given a
decomposition of $w$ into $u_1,u_2,\ldots, u_r$ (that is,
$w = u_1u_2\ldots u_r$) we can define the cost of the decomposition as
$\sum_{i=1}^r \cost(|u_i|)$.

For example if we define $\cost(h) = 1$ for all $h \ge 1$ then finding
a minimum cost palindromic decomposition of a given string $w$ is the
same as finding a decomposition of $w$ with as few palindromes as
possible. Suppose we define $\cost()$ as follows: $\cost(h) = 1$
for $h < k$ and $\cost(h) = 0$ for $h \ge k$. Then finding a
minimum cost palindromic decomposition would enable us to decide
whether there is a decomposition in which all palindromes are
of length at least $k$; it is possible iff the minimum cost is $0$.

Describe an efficient algorithm that given  black box access to
a function $\cost()$, and a string $w$, outputs the
value of a minimum cost palindromic decomposition of $w$.
\end{enumerate}

\hrule
\begin{solution}
$$ $$
\begin{enumerate}
    \item 
        In order to find the efficient algorithm for the minimum cost function, there will be two steps we need to perform. One is finding the different ways of decomposition and the second is finding which one decomposition will have the minimum cost when perform cost(). 
        \begin{itemize}
            \item  
            In the first step, we define a function $palindromList(w, idx, slist)$, which takes the string $w$ which is given to us, an int value $idx$ which show the current location and an list that is a sequence of number, the $i-1$th index(index starts from 0) in the list will be the length of $u_{(i)}$. 
            \newline
            The basic idea is we traverse the whole string from the beginning. Having a pointer start from the first char in the string, keep going to the end of the string. 
            \newline 
            We check if the substring that from beginning to the char the pointer is pointing at is a palindrome. Once it finds a palindrome, it will first push the length of the substring into a newly created list and then run palindromList function on the remaining substring and newly created list. If the it reaches the end and still not able to find a palindrome, it just returns. 
            $$ $$
            The function is provided below:
            \begin{quote}
                \newline
                \fbox{\begin{minipage}{30em}
                biglist = [] defining as a global variable 
                \newline
                check(w,idx) it's a function that return a boolean whether w($0$,idx) is palindrome
                \newline
                w(a,b) is the notion for the string w from index a till index b
                \newline 
                set the initial value of idx = 0 and slist = NULL
                \newline
                \newline
                palindromList(w, idx, slist):
                \quote
                while(idx < len(w)):
                \begin{itemize}
                    \item if(idx == len(w) - $1$):
                    \begin{itemize}
                        \item if(check(w,idx) == true):
                         \begin{itemize}
                             \item tempList = slist
                             \item tempList.push(len(w($0$,idx)))
                             \item biglist.push(tempList)
                        \end{itemize}
                        \item return
                    \end{itemize}
                    if(check(w,idx) == true):
                        \begin{itemize}
                             \item tempList = slist
                             \item tempList.push(len(w($0$,idx)))
                             \item palindromList(w(idx+$1$), 0, tempList)
                        \end{itemize}
                    \medskip
                    idx++
                \end{itemize}
                return 
                \end{minipage}}
            \end{quote}
        \item After first step, we have to compute the minimum cost by use the labels in each small list in the biglist, since cost function will only take the length parameter, the item we stored in the small list is each component palindrome's length. We simply take a small list at a time and find the small list that has least cost time and return it.     
        \end{itemize}
    Combine two steps, the total time algorithm will be $O(n^3)$. Since we have to do palindromList function for every index from start to end, if each time the process takes $O(1)$, there is $(1+n)*n/2$ steps for the first $u_1$ choosing the starting string length $1$, the string length is $n$, then the total time for palindromList is $n * (1+n)*n/2$, which is $O(n^3)$. The selecting smallest will be the number of list generated, which is at most $O(n^3)$ since we only did that much action. So the total algorithm time will be $O(n^3)$.
\end{enumerate}
\end{solution}
\end{document}
